### Oracle数据库

##### 创建表

```sql
create table OA_LEAVE_REGEDIT (
  REGEDIT_ID         varchar2(36) constraint OA_KEY_LEAVEREGEDIT primary key,
  LEAVETYPE_ID       varchar2(36),
  START_TIME         date,
  END_TIME         date,
  LEAVE_DAY        number(10),
  AMOUNT           number(10),
  SHUOMING         varchar2(500),
  GONGHAO          varchar2(36),
  CREATE_BY        varchar2(50),
  CREATE_TIME      date,
  UPDATE_BY        varchar2(50),
  UPDATE_TIME      date
);
```

##### 查询

```sql
select * from SYS_MENU t where menu_id=''

select * from SYS_MENU t where menu_type='M'

select * from SYS_MENU t where parent_id=603 and menu_name='科室管理';

select * from SYS_MENU t where menu_name='科别管理';

select * from SYS_MENU t where parent_id=10802084 and menu_name='人事档案管理';
```

##### 更新

```sql
update SYS_MENU s set s.parent_id=603 where s.parent_id=10802084 and s.menu_name='科室管理';

update SYS_MENU s set s.menu_name='组织机构管理' where s.parent_id=603 and s.menu_name='科室管理';

update SYS_MENU s set s.order_num=2 where s.parent_id=10802084 and s.menu_name='人事档案管理';

update SYS_MENU s set s.order_num=1 where s.parent_id=10802084 and s.menu_name='科室管理';
```

##### 添加

```sql
insert into sys_menu(
menu_id,
    parent_id,
   menu_name,
  order_num,
   path,
component,
is_frame,
is_cache,
menu_type,
visible,
status,
perms,
icon,
remark,
create_by,
url,
target)  values(
'603',
10802084,
'组织机构与岗位管理',
1,
'',
'',
1,
0,
'C',
0,
0,
'',
'fa fa-cubes tree',
'',
'',
'',
'menuItem'
)
```

##### 添加表字段

```sql
alter table 你需要修改的表的名字 add (你需要添加的字段的名字 varchar2(60) );//添加字符型字段

alter table 你需要修改的表的名字 add (你需要添加的字段的名字 number(60) );//添加数字型字段

comment on column 你刚刚修改的表的名字.你刚刚增加的表字段的名字 is ‘你想要给字段的注释’;//注意后面的单引号

alter table X_KESHI add (dict_type varchar2(60) );//添加字符型字段
```

##### 修改表字段

```sql
--修改原字段名
alter table OA_LEAVE_REGEDIT rename column AMOUNT to AMOUNT_tmp;

--增加原字段相同名字的
alter table OA_LEAVE_REGEDIT add AMOUNT number(8,2);

--将原字段的数据赋值给新添加的字段
update OA_LEAVE_REGEDIT set AMOUNT=trim(AMOUNT_tmp);

--删除原字段
alter table OA_LEAVE_REGEDIT drop column AMOUNT_tmp;

alter table 表名 rename column 旧的字段名 to 新的字段名

alter table X_KESHI rename column DICTTYPEID to DICTID
```

##### 删除表数据

```sql
delete from X_KESHI t where t.keshiid='ZS2012121'

delete from X_KESHI t where t.keshiid in('ZS2056','ZS205646546','ZS2096')
```

##### 连接表
```sql
左连接	left join 表名 on 连接条件；左表全部查询
右连接 right join 表名 on 连接条件；右表全部查询
内连接 inner join 表名 on 连接条件；满足条件查询
```
###### on与where的区别
```txt
左连接时，后面用on写的条件，会查出所有的左表数据。
而在on后面再用where关键字写条件时，相当于把on的条件执行完后，产生一个新表，再去过滤掉不符合的数据。
即where不会把左表数据全部查询出来。
```

left join 表名 on 连接条件 and （其他条件）

left join 表名 on 连接条件 and （其他条件） where （其他条件）

```sql
select t.*,d.* from SYS_DICT_DATA d
right join sys_dict_type t
on d.dict_code=t.dict_id
```

##### 分组

根据查询结果集，分组。默认升序asc，指定desc降序

可按多个字段分组，优先级以依次排，可单个指定字段的升降序

分组作为sql语句的最后一列

```sql
select t.*,d.* from SYS_DICT_DATA d
right join sys_dict_type t
on d.dict_code=t.dict_id 
order by t.create_by,t.update_by desc,d.update_by
```

##### 去重

根据column_1,column_2,等列去重。

```sql
SELECT DISTINCT column_1,
    column_2,
        ...
        FROM
    table_name;
```

##### UPPER函数不区分大小写查询

UPPER函数不区分大小写
oracle拼接字符串：||

```html
 <select id="selectXKeshiList" parameterType="com.hongyang.system.domain.XKeshi" resultMap="XKeshiResult">
        <include refid="selectXKeshiVo"/>
        <where>
            <if test="keshiid != null  and keshiid != ''"> and KESHIID like '%' || #{keshiid} || '%'</if>
            <if test="keshimingcheng != null  and keshimingcheng != ''"> and KESHIMINGCHENG like '%' || #{keshimingcheng} || '%'</if>
            <if test="shifouqiyong != null  and shifouqiyong != ''"> and SHIFOUQIYONG = #{shifouqiyong}</if>
            <if test="yiyuanid != null  and yiyuanid != ''"> and YIYUANID = #{yiyuanid}</if>
            <if test="dictCode != null  and dictCode != ''"> and DICT_CODE = #{dictCode}</if>
            <if test="searchValue != null  and searchValue != ''">
                AND (
                    KESHIMINGCHENG LIKE '%' || #{searchValue} || '%'
                    OR UPPER(KESHIID) LIKE UPPER('%' || #{searchValue} || '%')
                    OR UPPER(PINYIN) LIKE UPPER('%' || #{searchValue} || '%')
                    OR UPPER(WUBI) LIKE UPPER('%' || #{searchValue} || '%')
                )
            </if>
        </where>
    </select>
```

##### 时间范围包含当前日期
to_date('字符串','yyyy-mm-dd')，字符串格式化为日期类型
判断字段是否在范围内：字段名 between 范围1 and 范围2
```sql
select * from OA_LEAVE_REGEDIT t
where to_date(sysdate,'yyyy-mm-dd') between to_date(t.start_time,'yyyy-mm-dd') and  to_date(t.end_time,'yyyy-mm-dd')
```
##### 综合案例
###### case选择结构
```sql
case when 条件 then （满足条件执行的代码）
         when 条件 then （满足条件执行的代码）
         else （满足条件执行的代码） end
```
###### like 模糊查询
```sql
where 字段名 like '%参数%'
```

###### 判空
```sql
字段 is null
```
###### 别名
```sql
字段 as dep_id
```
###### cast类型转换函数
```sql
cast（'需转换的参数' as 转换的目标类型）
cast（'需转换的参数' as varchar2(60)）
```
###### 连接字符串，|| 和 concat函数
```sql
'字符串1' || '字符串2'  结果：'字符串1字符串2'
concat('字符串1','字符串2') 结果：'字符串1字符串2'
```
###### xml转义字符
```sql
 xml中小于号需要转义  <![CDATA[ < ]]> 
```
###### to_char：将日期或数字转换为字符串
```sql
to_char(日期或数字类型,'格式')
to_char(日期或数字类型,'yyyy-mm-dd')
to_char(salary,’$99,999.99’)
```
###### order by排序
```sql
order by 字段1 ASC,字段2 DESC,字段3
ASC表示按升序排序
DESC表示按降序排序
```
###### 树查询
level关键字，查询树的层级
start with关键字，开始递归的条件
connect by prior，递归条件
```sql
select level,--层级
       t.name,
       t.mgrid,
       (prior name) mgrna,
       connect_by_isleaf, --是否叶子   是 1 否 0
       sys_connect_by_path(t.name, ',')--根节点到当前节点的路径
  from x_keshi t
 start with t.mgrid is null --开始条件
connect by prior id = t.mgrid --递归条件

select * from x_keshi t 
 start with t.keshiid='ZS20' --开始条件，从那个节点开始，包括当前节点
connect by prior t.keshiid =t.fuleikeshiid --递归条件,当前节点的id==子记录的父id

--查询一棵树，除去指定节点（可以有多个）及其子节点，留下剩下的节点。
--keshiid：科室id
--fuleikeshiid：父科室id
select * from x_keshi t where t.keshiid not in (
-- 查询当前节点（可用in）的所有子节点（包括自己）
select g.keshiid from x_keshi g

--开始条件，从那个节点开始，包括当前节点
--利用子查询，查询出多个节点，使得开始条件有多个；即递归查询出多棵树所有节点
 start with g.keshiid in (
       select f.keshiid from x_keshi f where f.shifoujixiaokeshi!='1'
 ) 
 
connect by prior g.keshiid =g.fuleikeshiid --递归条件,当前节点的id==子记录的父id
)

```

###### rownum 关键字 查一组数据的前10条
order by 必须在where后面，所以不能直接where rownum<11，而是先用子查询排好序，再加条件，然后再用where rownum<11，就可以了。
```sql
select * from (select * from Oa_Salary_Rank g order by g.salary_level) t
left join Oa_Salary_Level l
on t.rank_id=l.rank_id and t.rank_name='专技八级'
where rownum <3
 order by t.salary_level desc
```

```xml
<!--    查询公休的员工的请假时间横跨当月数据，开始小于当月1号开始，并且结束大于当月1号，考勤-->
    <select id="selectPublicPoolBig" resultMap="bankMaintainMap">
        select
		<!--case选择结构-->
        case when d.inpreparation_status  is null then ''
             when d.inpreparation_status='0' then '编内'
             when d.inpreparation_status='1' then '编外'
             else     '未知'   end as inpreparation_status,

        r.gonghao,

        case when d.dep_id  is null then '--'
             else x.keshimingcheng end
        AS dep_id,

        d.xingming,

        case when r.start_time  is null then ''
             when r.end_time> to_date(#{endTime},'yyyy-mm-dd') then cast(to_date(#{endTime},'yyyy-mm-dd')-to_date(#{startTime},'yyyy-mm-dd')+1 as varchar2(36))
             else cast( r.end_time-to_date(#{startTime},'yyyy-mm-dd')+1 as varchar2(36))   end as cutTime,


        case when r.start_time  is null then ''
              else to_char(r.start_time,'yyyy.mm.dd')   || '-' ||  to_char(r.end_time,'yyyy.mm.dd')   end
        as add_time,

        r.start_time,
        r.end_time,
        r.leave_day,
        t.leave_name

        from Oa_Leave_Regedit r

        inner join Oa_DANGANJIBENINFO d
        on r.gonghao=d.gonghao
        and r.start_time <![CDATA[ < ]]> to_date(#{startTime},'yyyy-mm-dd')
        and r.end_time >=to_date(#{startTime},'yyyy-mm-dd')

        inner join OA_LEAVE_TYPE t
        on r.leavetype_id=t.leaveid
        and t.public_leave=1

        left join x_keshi x
        on x.keshiid =d.dep_id order by d.dep_id,d.gonghao,add_time

    </select>
```
###### 数据库的入门介绍；使用的数据结构等
```html
https://cloud.tencent.com/developer/article/2124587
```


